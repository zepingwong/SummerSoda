(window.webpackJsonp=window.webpackJsonp||[]).push([[374],{943:function(e,a,t){"use strict";t.r(a);var r=t(2),s=Object(r.a)({},(function(){var e=this,a=e._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('# 实例化，构造函数的参数会作为Flask app核心对象的标识\napp = Flask(__name__)\n# 启动web app\n# debug=True开启调试模式 1.修改文件后不用每次都重启服务器 2.可以在网页中显示异常\n# host可以指定可以访问本网站的ip地址\n# port启动端口\napp.run(host="0.0.0.0", port=81, debug=True)\n')])])]),a("h2",{attrs:{id:"_3-注册路由-法1"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-注册路由-法1"}},[e._v("#")]),e._v(" 3.注册路由-法1")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('# 通过@app.route装饰器来注册路由，其中的参数为url路径。对应会调用hello()函数\n@app.route("/hello")\ndef hello():\n    """定义视图函数-mvc 中的controller"""\n    return "我就不说hello world"\n')])])]),a("p",[e._v("如果直接使用/hello 那么不能兼容浏览器不能访问/hello/和/hello，解决办法，路径定义改成/hello/")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('@app.route("/hello/")\ndef hello():\n    return "我就不说hello world"\n')])])]),a("h3",{attrs:{id:"在路径xxx后添加斜杠-后就可以访问xxx-和-xxx的原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#在路径xxx后添加斜杠-后就可以访问xxx-和-xxx的原理"}},[e._v("#")]),e._v(" 在路径xxx后添加斜杠/后就可以访问xxx/ 和 xxx的原理")]),e._v(" "),a("p",[e._v("重定向：当你访问url1的时候，服务器返回状态码302让用户访问url2\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/7220971-4f5d1fe45268a7f2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"重定向"}})]),e._v(" "),a("p",[e._v("访问http://localhost:5000/hello,观察浏览器网络请求情况，可以看到发生了重定向，重定向到了hello/\n"),a("img",{attrs:{src:"https://upload-images.jianshu.io/upload_images/7220971-be441a733b86ae58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240",alt:"image.png"}})]),e._v(" "),a("h4",{attrs:{id:"为什么这么做呢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么这么做呢"}},[e._v("#")]),e._v(" 为什么这么做呢？")]),e._v(" "),a("p",[e._v("这是因为，如果不做重定向不带/ 的（hello）和带/的（hello/）都可以访问到视图函数，那么就是说同一个视图函数对应着两个不同的路由，没有保证唯一url的原则")]),e._v(" "),a("h4",{attrs:{id:"唯一url的好处"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#唯一url的好处"}},[e._v("#")]),e._v(" 唯一url的好处")]),e._v(" "),a("p",[e._v("如果有两个url，那么在搜索引擎中会被索引两次，这样会浪费性能，影响搜索引擎的优化，没有这个必要。")]),e._v(" "),a("h2",{attrs:{id:"_4-注册路由-法2"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-注册路由-法2"}},[e._v("#")]),e._v(" 4.注册路由-法2")]),e._v(" "),a("p",[e._v("另一种注册路由的函数，通过调用app的add_url_rule函数")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('app.add_url_rule("/hello",view_func=hello)\n')])])]),a("p",[e._v("实际上方法1装饰器的模式，内部就是调用了add_url_rule函数。下面来看一下源码")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("    def route(self, rule, **options):\n        \"\"\"A decorator that is used to register a view function for a\n        given URL rule.  This does the same thing as :meth:`add_url_rule`\n        but is intended for decorator usage::\n\n            @app.route('/')\n            def index():\n                return 'Hello World'\n\n        For more information refer to :ref:`url-route-registrations`.\n\n        :param rule: the URL rule as string\n        :param endpoint: the endpoint for the registered URL rule.  Flask\n                         itself assumes the name of the view function as\n                         endpoint\n        :param options: the options to be forwarded to the underlying\n                        :class:`~werkzeug.routing.Rule` object.  A change\n                        to Werkzeug is handling of method options.  methods\n                        is a list of methods this rule should be limited\n                        to (``GET``, ``POST`` etc.).  By default a rule\n                        just listens for ``GET`` (and implicitly ``HEAD``).\n                        Starting with Flask 0.6, ``OPTIONS`` is implicitly\n                        added and handled by the standard request handling.\n        \"\"\"\n        def decorator(f):\n            endpoint = options.pop('endpoint', None)\n            # 可以看到这里就是调用了add_url_rule，self就是我们实例化的app对象\n            self.add_url_rule(rule, endpoint, f, **options)\n            return f\n        return decorator\n")])])]),a("h2",{attrs:{id:"_5-falsk配置文件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-falsk配置文件"}},[e._v("#")]),e._v(" 5.falsk配置文件")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('# 载入配置文件\napp.config.from_object("config")\n# 读取配置文件\nprint(app.config["DEBUG"])\n')])])]),a("p",[e._v("陷阱1：配置文件中的key必须是全大写\n陷阱2：DEBUG是flask里的一个默认变量，如果想要覆盖，必须名字一模一样")]),e._v(" "),a("h2",{attrs:{id:"_5-if-name-main"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_5-if-name-main"}},[e._v("#")]),e._v(" 5.if "),a("strong",[e._v("name")]),e._v(' = "'),a("strong",[e._v("main")]),e._v('"')]),e._v(" "),a("p",[e._v("简单理解：加入这个判断以后，只有在启动入口文件以后，才会执行。而在被其他模块导入的时候不会执行")]),e._v(" "),a("p",[e._v("深入理解其原因是：在生产环境中，我们是使用nginx+uwsgi来部署python项目，其中uwsgi用来启动flask服务，这个时候，根本fisher.py只是作为一个模块被调用，这时加上入口判断，在生产环境中就只不会执行"),a("code",[e._v("app.run")]),e._v("方法。否则的话就会启动两个flask服务。")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v('if __name__ == "__name__":\n    app.run(host=app.config["HOST"], debug=app.config["DEBUG"], port=app.config["PORT"])\n')])])])])}),[],!1,null,null,null);a.default=s.exports}}]);